// DRN adaptation to drive PIC24F Starter Kit's SH1101A OLED display
// Dave.Nadler@Nadler.com 15-August-2012

/*
 * Warning !  This code uses some Microchip-distributed graphics
 * support. Microchip's code works but beware of horrendous global
 * names like "DeviceRead" - there's no intelligent name prefixing to
 * separate code for numerous different kind of devices - and lots of
 * globals...
 *
 * The code below provides a few primitives to support FreeRTOS
 * PIC24F demonstration code access to the OLED SH1101 display on
 * Microchip's PIC24F Starter Kit board.
 *
*/


#include "PIC24F_StarterKit_OLED.h" // public interface to this module

#include "HardwareProfile.h" // project-specific hardware configuration
#include "GraphicsConfig.h"  // project-specific configuration of Microchip Graphics Library
#include "Graphics/Graphics.h"  // Microchip Graphics library (ClearDevice, PutPixel, _color)
#include "Graphics/gfxpmp.h"    // Microchip PMP driver support (DriverInterfaceInit, ROM, DeviceRead, DeviceWrite)

// Map gfxpmp functions to names used in PIC24F OLED_ .c code below
#define OLED_Read()           DeviceRead()      // Unbelievable name; code in SH1101 driver
#define OLED_Write(_x)        DeviceWrite((_x)) // Unbelievable name; code in SH1101 driver
#define OLED_WriteCommand(_x) {OLED_SetCommand(); DeviceWrite((_x));}
#define OLED_WriteData(_x)    {OLED_SetData();    DeviceWrite((_x));}

#define OFFSET  2 // Defines the display offset in x direction (WTF ???).



/*********************************************************************
* Function: OLED_Init
* Overview: 
* Input:
* Output: 
********************************************************************/
void OLED_Init(void)
{
    DriverInterfaceInit(); // initialize PMP parallel port (definition in gfxpmp.h)

    // Initialize the MCU pins
    OLED_ConfigPins();
    OLED_Select();
    OLED_SetCommand();

    // Setup Display
    OLED_Write(0xAE);             // turn off the display (AF=ON, AE=OFF)
    OLED_Write(0xDB);             // set  VCOMH
    OLED_Write(0x23);
    OLED_Write(0xD9);             // set  VP
    OLED_Write(0x22);

    // Re-map
    OLED_Write(0xA1);             // [A0]:column address 0 is map to SEG0
                                  // [A1]:column address 131 is map to SEG0
    // COM Output Scan Direction
    OLED_Write(0xC8);             // C0 is COM0 to COMn, C8 is COMn to COM0

    // COM Pins Hardware Configuration
    OLED_Write(0xDA);             // set pins hardware configuration
    OLED_Write(0x12);

    // Multiplex Ratio
    OLED_Write(0xA8);             // set multiplex ratio
    OLED_Write(0x3F);             // set to 64 mux

    // Display Clock Divide
    OLED_Write(0xD5);             // set display clock divide
    OLED_Write(0xA0);             // set to 100Hz

    // Contrast Control Register
    OLED_Write(0x81);             // Set contrast control
    OLED_Write(0x60);             // display 0 ~ 127; 2C

    // Display Offset
    OLED_Write(0xD3);             // set display offset
    OLED_Write(0x00);             // no offset

    //Normal or Inverse Display
    OLED_Write(0xA6);             // Normal display

    OLED_Write(0xAD);             // Set DC-DC
    OLED_Write(0x8B);             // 8B=ON, 8A=OFF

    // Display ON/OFF
    OLED_Write(0xAF);             // AF=ON, AE=OFF

    DelayMs(150);

    // Entire Display ON/OFF
    OLED_Write(0xA4);             // A4=ON
    // Display Start Line
    OLED_Write(0x40);             // Set display start line
    // Lower Column Address
    OLED_Write(0x00 + OFFSET);    // Set lower column address
    // Higher Column Address
    OLED_Write(0x10);             // Set higher column address

    DelayMs(1);

    OLED_Clear();

    OLED_Deselect();
    OLED_SetData();
}

void OLED_Clear(void) {
    OLED_Set_Color(0);
    ClearDevice();
}

static void OLED_SetRAMaddr(BYTE page/* ie, row+xB0 */, BYTE column) {
    BYTE lowerAddr =  column    &0x0F;
    BYTE higherAddr= (column>>4)&0x0F;
    OLED_SetCommand(); 
    OLED_Write(page);
    OLED_Write(0x00+lowerAddr); 
    OLED_Write(0x10+higherAddr); 
    OLED_SetData();
}

void OLED_Set_Color(BYTE color) { _color = color; };


/*********************************************************************
* Function: Line
* Overview: 
* Input:
* Output: 
********************************************************************/
WORD OLED_Draw_Line(SHORT x1, SHORT y1, SHORT x2, SHORT y2)
{
    SHORT   deltaX, deltaY;
    SHORT   error, stepErrorLT, stepErrorGE;
    SHORT   stepX, stepY;
    SHORT   steep;
    SHORT   temp;
    SHORT   style, type;

    // Current line type
    SHORT   _lineType=0;
    
    // Current line thickness
    BYTE    _lineThickness=0;

    if(x1 == x2)
    {
        if(y1 > y2)
        {
            temp = y1;
            y1 = y2;
            y2 = temp;
        }
        style = 0;
        type = 1;
        for(temp = y1; temp < y2 + 1; temp++)
        {
            if((++style) == _lineType)
            {
                type ^= 1;
                style = 0;
            }
            if(type)
            {
                PutPixel(x1, temp);
                if(_lineThickness)
                {
                    PutPixel(x1 + 1, temp);
                    PutPixel(x1 - 1, temp);
                }
            }
        }
        return (1);
    }
    if(y1 == y2)
    {
        if(x1 > x2)
        {
            temp = x1;
            x1 = x2;
            x2 = temp;
        }
        style = 0;
        type = 1;
        for(temp = x1; temp < x2 + 1; temp++)
        {
            if((++style) == _lineType)
            {
                type ^= 1;
                style = 0;
            }
            if(type)
            {
                PutPixel(temp, y1);
                if(_lineThickness)
                {
                    PutPixel(temp, y1 + 1);
                    PutPixel(temp, y1 - 1);
                }
            }
        }
        return (1);
    }
    stepX = 0;
    deltaX = x2 - x1;
    if(deltaX < 0)
    {
        deltaX = -deltaX;
        --stepX;
    }
    else
    {
        ++stepX;
    }
    stepY = 0;
    deltaY = y2 - y1;
    if(deltaY < 0)
    {
        deltaY = -deltaY;
        --stepY;
    }
    else
    {
        ++stepY;
    }
    steep = 0;
    if(deltaX < deltaY)
    {
        ++steep;
        temp = deltaX;
        deltaX = deltaY;
        deltaY = temp;
        temp = x1;
        x1 = y1;
        y1 = temp;
        temp = stepX;
        stepX = stepY;
        stepY = temp;
        PutPixel(y1, x1);
    }
    else
    {
        PutPixel(x1, y1);
    }
    // If the current error greater or equal zero
    stepErrorGE = deltaX << 1;

    // If the current error less than zero
    stepErrorLT = deltaY << 1;

    // Error for the first pixel
    error = stepErrorLT - deltaX;

    style = 0;
    type = 1;

    while(--deltaX >= 0)
    {
        if(error >= 0)
        {
            y1 += stepY;
            error -= stepErrorGE;
        }

        x1 += stepX;
        error += stepErrorLT;

        if((++style) == _lineType)
        {
            type ^= 1;
            style = 0;
        }

        if(type)
        {
            if(steep)
            {
                PutPixel(y1, x1);
                if(_lineThickness)
                {
                    PutPixel(y1 + 1, x1);
                    PutPixel(y1 - 1, x1);
                }
            }
            else
            {
                PutPixel(x1, y1);
                if(_lineThickness)
                {
                    PutPixel(x1, y1 + 1);
                    PutPixel(x1, y1 - 1);
                }
            }
        }
    }   // end of while

    return (1);
}


/*********************************************************************
* Function: OLED_Draw_Box(SHORT left, SHORT top, SHORT right, SHORT bottom)
* Input: left,top - top left corner coordinates,
*        right,bottom - bottom right corner coordinates
* Output: Always return 1.
*
*    left,top  +---+
*              |   |
*              |   |
*              |   |
*              |   |
*              |   |
*              |   |
*              +---+ right,bottom
*   
********************************************************************/
WORD OLED_Draw_Box(SHORT left, SHORT top, SHORT right, SHORT bottom)
{
    SHORT x, y;
    for(y=top; y<bottom+1; y++)
        for(x=left; x<right+1; x++)
            PutPixel(x, y);
    return 1;
}

// FontName : Terminal8x6
// FontSize : 8 x 6
ROM BYTE Terminal8x6[][6] = 
    {
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },      // Code for char  
        { 0x00, 0x00, 0x06, 0x5F, 0x06, 0x00 },      // Code for char !
        { 0x00, 0x07, 0x03, 0x00, 0x07, 0x03 },      // Code for char "
        { 0x00, 0x24, 0x7E, 0x24, 0x7E, 0x24 },      // Code for char #
        { 0x00, 0x24, 0x2B, 0x6A, 0x12, 0x00 },      // Code for char $
        { 0x00, 0x63, 0x13, 0x08, 0x64, 0x63 },      // Code for char %
        { 0x00, 0x36, 0x49, 0x56, 0x20, 0x50 },      // Code for char &
        { 0x00, 0x00, 0x07, 0x03, 0x00, 0x00 },      // Code for char '
        { 0x00, 0x00, 0x3E, 0x41, 0x00, 0x00 },      // Code for char (
        { 0x00, 0x00, 0x41, 0x3E, 0x00, 0x00 },      // Code for char )
        { 0x00, 0x08, 0x3E, 0x1C, 0x3E, 0x08 },      // Code for char *
        { 0x00, 0x08, 0x08, 0x3E, 0x08, 0x08 },      // Code for char +
        { 0x00, 0x00, 0xE0, 0x60, 0x00, 0x00 },      // Code for char ,
        { 0x00, 0x08, 0x08, 0x08, 0x08, 0x08 },      // Code for char -
        { 0x00, 0x00, 0x60, 0x60, 0x00, 0x00 },      // Code for char .
        { 0x00, 0x20, 0x10, 0x08, 0x04, 0x02 },      // Code for char /
        { 0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E },      // Code for char 0
        { 0x00, 0x00, 0x42, 0x7F, 0x40, 0x00 },      // Code for char 1
        { 0x00, 0x62, 0x51, 0x49, 0x49, 0x46 },      // Code for char 2
        { 0x00, 0x22, 0x49, 0x49, 0x49, 0x36 },      // Code for char 3
        { 0x00, 0x18, 0x14, 0x12, 0x7F, 0x10 },      // Code for char 4
        { 0x00, 0x2F, 0x49, 0x49, 0x49, 0x31 },      // Code for char 5
        { 0x00, 0x3C, 0x4A, 0x49, 0x49, 0x30 },      // Code for char 6
        { 0x00, 0x01, 0x71, 0x09, 0x05, 0x03 },      // Code for char 7
        { 0x00, 0x36, 0x49, 0x49, 0x49, 0x36 },      // Code for char 8
        { 0x00, 0x06, 0x49, 0x49, 0x29, 0x1E },      // Code for char 9
        { 0x00, 0x00, 0x6C, 0x6C, 0x00, 0x00 },      // Code for char :
        { 0x00, 0x00, 0xEC, 0x6C, 0x00, 0x00 },      // Code for char ;
        { 0x00, 0x08, 0x14, 0x22, 0x41, 0x00 },      // Code for char <
        { 0x00, 0x24, 0x24, 0x24, 0x24, 0x24 },      // Code for char =
        { 0x00, 0x00, 0x41, 0x22, 0x14, 0x08 },      // Code for char >
        { 0x00, 0x02, 0x01, 0x59, 0x09, 0x06 },      // Code for char ?
        { 0x00, 0x3E, 0x41, 0x5D, 0x55, 0x1E },      // Code for char @
        { 0x00, 0x7E, 0x11, 0x11, 0x11, 0x7E },      // Code for char A
        { 0x00, 0x7F, 0x49, 0x49, 0x49, 0x36 },      // Code for char B
        { 0x00, 0x3E, 0x41, 0x41, 0x41, 0x22 },      // Code for char C
        { 0x00, 0x7F, 0x41, 0x41, 0x41, 0x3E },      // Code for char D
        { 0x00, 0x7F, 0x49, 0x49, 0x49, 0x41 },      // Code for char E
        { 0x00, 0x7F, 0x09, 0x09, 0x09, 0x01 },      // Code for char F
        { 0x00, 0x3E, 0x41, 0x49, 0x49, 0x7A },      // Code for char G
        { 0x00, 0x7F, 0x08, 0x08, 0x08, 0x7F },      // Code for char H
        { 0x00, 0x00, 0x41, 0x7F, 0x41, 0x00 },      // Code for char I
        { 0x00, 0x30, 0x40, 0x40, 0x40, 0x3F },      // Code for char J
        { 0x00, 0x7F, 0x08, 0x14, 0x22, 0x41 },      // Code for char K
        { 0x00, 0x7F, 0x40, 0x40, 0x40, 0x40 },      // Code for char L
        { 0x00, 0x7F, 0x02, 0x04, 0x02, 0x7F },      // Code for char M
        { 0x00, 0x7F, 0x02, 0x04, 0x08, 0x7F },      // Code for char N
        { 0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E },      // Code for char O
        { 0x00, 0x7F, 0x09, 0x09, 0x09, 0x06 },      // Code for char P
        { 0x00, 0x3E, 0x41, 0x51, 0x21, 0x5E },      // Code for char Q
        { 0x00, 0x7F, 0x09, 0x09, 0x19, 0x66 },      // Code for char R
        { 0x00, 0x26, 0x49, 0x49, 0x49, 0x32 },      // Code for char S
        { 0x00, 0x01, 0x01, 0x7F, 0x01, 0x01 },      // Code for char T
        { 0x00, 0x3F, 0x40, 0x40, 0x40, 0x3F },      // Code for char U
        { 0x00, 0x1F, 0x20, 0x40, 0x20, 0x1F },      // Code for char V
        { 0x00, 0x3F, 0x40, 0x3C, 0x40, 0x3F },      // Code for char W
        { 0x00, 0x63, 0x14, 0x08, 0x14, 0x63 },      // Code for char X
        { 0x00, 0x07, 0x08, 0x70, 0x08, 0x07 },      // Code for char Y
        { 0x00, 0x71, 0x49, 0x45, 0x43, 0x00 },      // Code for char Z
        { 0x00, 0x00, 0x7F, 0x41, 0x41, 0x00 },      // Code for char [
        { 0x00, 0x02, 0x04, 0x08, 0x10, 0x20 },      // Code for char BackSlash
        { 0x00, 0x00, 0x41, 0x41, 0x7F, 0x00 },      // Code for char ]
        { 0x00, 0x04, 0x02, 0x01, 0x02, 0x04 },      // Code for char ^
        { 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },      // Code for char _
        { 0x00, 0x00, 0x03, 0x07, 0x00, 0x00 },      // Code for char `
        { 0x00, 0x20, 0x54, 0x54, 0x54, 0x78 },      // Code for char a
        { 0x00, 0x7F, 0x44, 0x44, 0x44, 0x38 },      // Code for char b
        { 0x00, 0x38, 0x44, 0x44, 0x44, 0x28 },      // Code for char c
        { 0x00, 0x38, 0x44, 0x44, 0x44, 0x7F },      // Code for char d
        { 0x00, 0x38, 0x54, 0x54, 0x54, 0x08 },      // Code for char e
        { 0x00, 0x08, 0x7E, 0x09, 0x09, 0x00 },      // Code for char f
        { 0x00, 0x18, 0xA4, 0xA4, 0xA4, 0x7C },      // Code for char g
        { 0x00, 0x7F, 0x04, 0x04, 0x78, 0x00 },      // Code for char h
        { 0x00, 0x00, 0x00, 0x7D, 0x40, 0x00 },      // Code for char i
        { 0x00, 0x40, 0x80, 0x84, 0x7D, 0x00 },      // Code for char j
        { 0x00, 0x7F, 0x10, 0x28, 0x44, 0x00 },      // Code for char k
        { 0x00, 0x00, 0x00, 0x7F, 0x40, 0x00 },      // Code for char l
        { 0x00, 0x7C, 0x04, 0x18, 0x04, 0x78 },      // Code for char m
        { 0x00, 0x7C, 0x04, 0x04, 0x78, 0x00 },      // Code for char n
        { 0x00, 0x38, 0x44, 0x44, 0x44, 0x38 },      // Code for char o
        { 0x00, 0xFC, 0x44, 0x44, 0x44, 0x38 },      // Code for char p
        { 0x00, 0x38, 0x44, 0x44, 0x44, 0xFC },      // Code for char q
        { 0x00, 0x44, 0x78, 0x44, 0x04, 0x08 },      // Code for char r
        { 0x00, 0x08, 0x54, 0x54, 0x54, 0x20 },      // Code for char s
        { 0x00, 0x04, 0x3E, 0x44, 0x24, 0x00 },      // Code for char t
        { 0x00, 0x3C, 0x40, 0x20, 0x7C, 0x00 },      // Code for char u
        { 0x00, 0x1C, 0x20, 0x40, 0x20, 0x1C },      // Code for char v
        { 0x00, 0x3C, 0x60, 0x30, 0x60, 0x3C },      // Code for char w
        { 0x00, 0x6C, 0x10, 0x10, 0x6C, 0x00 },      // Code for char x
        { 0x00, 0x9C, 0xA0, 0x60, 0x3C, 0x00 },      // Code for char y
        { 0x00, 0x64, 0x54, 0x54, 0x4C, 0x00 },      // Code for char z
        { 0x00, 0x08, 0x3E, 0x41, 0x41, 0x00 },      // Code for char {
        { 0x00, 0x00, 0x00, 0x77, 0x00, 0x00 },      // Code for char |
        { 0x00, 0x00, 0x41, 0x41, 0x3E, 0x08 },      // Code for char }
        { 0x00, 0x02, 0x01, 0x02, 0x01, 0x00 },      // Code for char ~
        { 0x00, 0x3C, 0x26, 0x23, 0x26, 0x3C },      // Code for char 
        { 0x00, 0x00, 0x03, 0x07, 0x00, 0x00 },      // Code for char Ä
        { 0x00, 0x3D, 0x40, 0x20, 0x7D, 0x00 },      // Code for char Å
        { 0x00, 0x00, 0x03, 0x07, 0x00, 0x00 },      // Code for char Ç
        { 0x00, 0x00, 0x03, 0x07, 0x00, 0x00 },      // Code for char É
        { 0x00, 0x00, 0x03, 0x07, 0x00, 0x00 },      // Code for char Ñ
        { 0x00, 0x00, 0x03, 0x07, 0x00, 0x00 },      // Code for char Ö
        { 0x00, 0x00, 0x03, 0x07, 0x00, 0x00 },      // Code for char Ü
        { 0x00, 0x00, 0x03, 0x07, 0x00, 0x00 },      // Code for char á
        { 0x00, 0x00, 0x03, 0x07, 0x00, 0x00 },      // Code for char à
        { 0x00, 0x00, 0x03, 0x07, 0x00, 0x00 },      // Code for char â
        { 0x00, 0x00, 0x03, 0x07, 0x00, 0x00 },      // Code for char ä
        { 0x00, 0x00, 0x03, 0x07, 0x00, 0x00 },      // Code for char ã
        { 0x00, 0x00, 0x03, 0x07, 0x00, 0x00 },      // Code for char å
        { 0x00, 0x00, 0x01, 0x7C, 0x40, 0x00 },      // Code for char ç
        { 0x00, 0x00, 0x03, 0x07, 0x00, 0x00 },      // Code for char é
        { 0x00, 0x78, 0x2F, 0x25, 0x2F, 0x78 },      // Code for char è
        { 0x00, 0x7C, 0x54, 0x54, 0x55, 0x45 },      // Code for char ê
        { 0x00, 0x00, 0x03, 0x07, 0x00, 0x00 },      // Code for char ë
        { 0x00, 0x00, 0x03, 0x07, 0x00, 0x00 },      // Code for char í
        { 0x00, 0x00, 0x03, 0x07, 0x00, 0x00 },      // Code for char ì
        { 0x00, 0x00, 0x03, 0x07, 0x00, 0x00 },      // Code for char î
        { 0x00, 0x00, 0x03, 0x07, 0x00, 0x00 },      // Code for char ï
        { 0x00, 0x00, 0x03, 0x07, 0x00, 0x00 },      // Code for char ñ
        { 0x00, 0x00, 0x03, 0x07, 0x00, 0x00 },      // Code for char ó
        { 0x00, 0x00, 0x03, 0x07, 0x00, 0x00 },      // Code for char ò
        { 0x00, 0x00, 0x03, 0x07, 0x00, 0x00 },      // Code for char ô
        { 0x00, 0x00, 0x03, 0x07, 0x00, 0x00 },      // Code for char ö
        { 0x00, 0x00, 0x03, 0x07, 0x00, 0x00 },      // Code for char õ
        { 0x00, 0x00, 0x03, 0x07, 0x00, 0x00 },      // Code for char ú
        { 0x00, 0x29, 0x2A, 0x7C, 0x2A, 0x29 },      // Code for char ù
        { 0x00, 0x00, 0x03, 0x07, 0x00, 0x00 },      // Code for char û
        { 0x00, 0x00, 0x03, 0x07, 0x00, 0x00 },      // Code for char ü
        { 0x00, 0x20, 0x54, 0x55, 0x55, 0x78 },      // Code for char †
        { 0x00, 0x00, 0x00, 0x7D, 0x41, 0x00 },      // Code for char °
        { 0x00, 0x38, 0x44, 0x45, 0x39, 0x00 },      // Code for char ¢
        { 0x00, 0x3C, 0x40, 0x21, 0x7D, 0x00 },      // Code for char £
        { 0x00, 0x7A, 0x09, 0x0A, 0x71, 0x00 },      // Code for char §
        { 0x00, 0x7A, 0x11, 0x22, 0x79, 0x00 },      // Code for char •
        { 0x00, 0x08, 0x55, 0x55, 0x55, 0x5E },      // Code for char ¶
        { 0x00, 0x4E, 0x51, 0x51, 0x4E, 0x00 },      // Code for char ß
        { 0x00, 0x30, 0x48, 0x4D, 0x40, 0x20 },      // Code for char ®
        { 0x00, 0x3C, 0x04, 0x04, 0x04, 0x04 },      // Code for char ©
        { 0x04, 0x04, 0x04, 0x04, 0x04, 0x1C },      // Code for char ™
        { 0x00, 0x17, 0x08, 0x4C, 0x6A, 0x50 },      // Code for char ´
        { 0x00, 0x17, 0x08, 0x34, 0x2A, 0x78 },      // Code for char ¨
        { 0x00, 0x00, 0x30, 0x7D, 0x30, 0x00 },      // Code for char ≠
        { 0x00, 0x08, 0x14, 0x00, 0x08, 0x14 },      // Code for char Æ
        { 0x00, 0x14, 0x08, 0x00, 0x14, 0x08 },      // Code for char Ø
        { 0x44, 0x11, 0x44, 0x11, 0x44, 0x11 },      // Code for char ∞
        { 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55 },      // Code for char ±
        { 0xBB, 0xEE, 0xBB, 0xEE, 0xBB, 0xEE },      // Code for char ≤
        { 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00 },      // Code for char ≥
        { 0x08, 0x08, 0x08, 0xFF, 0x00, 0x00 },      // Code for char ¥
        { 0x0A, 0x0A, 0x0A, 0xFF, 0x00, 0x00 },      // Code for char µ
        { 0x08, 0xFF, 0x00, 0xFF, 0x00, 0x00 },      // Code for char ∂
        { 0x08, 0xF8, 0x08, 0xF8, 0x00, 0x00 },      // Code for char ∑
        { 0x0A, 0x0A, 0x0A, 0xFE, 0x00, 0x00 },      // Code for char ∏
        { 0x0A, 0xFB, 0x00, 0xFF, 0x00, 0x00 },      // Code for char π
        { 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00 },      // Code for char ∫
        { 0x0A, 0xFA, 0x02, 0xFE, 0x00, 0x00 },      // Code for char ª
        { 0x0A, 0x0B, 0x08, 0x0F, 0x00, 0x00 },      // Code for char º
        { 0x08, 0x0F, 0x08, 0x0F, 0x00, 0x00 },      // Code for char Ω
        { 0x0A, 0x0A, 0x0A, 0x0F, 0x00, 0x00 },      // Code for char æ
        { 0x08, 0x08, 0x08, 0xF8, 0x00, 0x00 },      // Code for char ø
        { 0x00, 0x00, 0x00, 0x0F, 0x08, 0x08 },      // Code for char ¿
        { 0x08, 0x08, 0x08, 0x0F, 0x08, 0x08 },      // Code for char ¡
        { 0x08, 0x08, 0x08, 0xF8, 0x08, 0x08 },      // Code for char ¬
        { 0x00, 0x00, 0x00, 0xFF, 0x08, 0x08 },      // Code for char √
        { 0x08, 0x08, 0x08, 0x08, 0x08, 0x08 },      // Code for char ƒ
        { 0x08, 0x08, 0x08, 0xFF, 0x08, 0x08 },      // Code for char ≈
        { 0x00, 0x00, 0x00, 0xFF, 0x0A, 0x0A },      // Code for char ∆
        { 0x00, 0xFF, 0x00, 0xFF, 0x08, 0x08 },      // Code for char «
        { 0x00, 0x0F, 0x08, 0x0B, 0x0A, 0x0A },      // Code for char »
        { 0x00, 0xFE, 0x02, 0xFA, 0x0A, 0x0A },      // Code for char …
        { 0x0A, 0x0B, 0x08, 0x0B, 0x0A, 0x0A },      // Code for char  
        { 0x0A, 0xFA, 0x02, 0xFA, 0x0A, 0x0A },      // Code for char À
        { 0x00, 0xFF, 0x00, 0xFB, 0x0A, 0x0A },      // Code for char Ã
        { 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A },      // Code for char Õ
        { 0x0A, 0xFB, 0x00, 0xFB, 0x0A, 0x0A },      // Code for char Œ
        { 0x0A, 0x0A, 0x0A, 0x0B, 0x0A, 0x0A },      // Code for char œ
        { 0x08, 0x0F, 0x08, 0x0F, 0x08, 0x08 },      // Code for char –
        { 0x0A, 0x0A, 0x0A, 0xFA, 0x0A, 0x0A },      // Code for char —
        { 0x08, 0xF8, 0x08, 0xF8, 0x08, 0x08 },      // Code for char “
        { 0x00, 0x0F, 0x08, 0x0F, 0x08, 0x08 },      // Code for char ”
        { 0x00, 0x00, 0x00, 0x0F, 0x0A, 0x0A },      // Code for char ‘
        { 0x00, 0x00, 0x00, 0xFE, 0x0A, 0x0A },      // Code for char ’
        { 0x00, 0xF8, 0x08, 0xF8, 0x08, 0x08 },      // Code for char ÷
        { 0x08, 0xFF, 0x00, 0xFF, 0x08, 0x08 },      // Code for char ◊
        { 0x0A, 0x0A, 0x0A, 0xFB, 0x0A, 0x0A },      // Code for char ÿ
        { 0x08, 0x08, 0x08, 0x0F, 0x00, 0x00 },      // Code for char Ÿ
        { 0x00, 0x00, 0x00, 0xF8, 0x08, 0x08 },      // Code for char ⁄
        { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },      // Code for char €
        { 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0 },      // Code for char ‹
        { 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00 },      // Code for char ›
        { 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF },      // Code for char ﬁ
        { 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F },      // Code for char ﬂ
        { 0x00, 0x18, 0x24, 0x24, 0x18, 0x24 },      // Code for char ‡
        { 0x00, 0xFE, 0x4A, 0x4A, 0x34, 0x00 },      // Code for char ·
        { 0x00, 0x7F, 0x01, 0x01, 0x03, 0x00 },      // Code for char ‚
        { 0x00, 0x02, 0x7E, 0x02, 0x7E, 0x02 },      // Code for char „
        { 0x00, 0x63, 0x55, 0x49, 0x63, 0x00 },      // Code for char ‰
        { 0x00, 0x18, 0x24, 0x24, 0x1C, 0x04 },      // Code for char Â
        { 0x00, 0xFC, 0x20, 0x20, 0x1C, 0x00 },      // Code for char Ê
        { 0x00, 0x08, 0x04, 0x78, 0x04, 0x00 },      // Code for char Á
        { 0x00, 0x08, 0x55, 0x77, 0x55, 0x08 },      // Code for char Ë
        { 0x00, 0x3E, 0x49, 0x49, 0x3E, 0x00 },      // Code for char È
        { 0x00, 0x4C, 0x72, 0x02, 0x72, 0x4C },      // Code for char Í
        { 0x00, 0x22, 0x55, 0x59, 0x30, 0x00 },      // Code for char Î
        { 0x00, 0x18, 0x24, 0x18, 0x24, 0x18 },      // Code for char Ï
        { 0x00, 0x18, 0x24, 0x7E, 0x24, 0x18 },      // Code for char Ì
        { 0x00, 0x1C, 0x2A, 0x2A, 0x2A, 0x00 },      // Code for char Ó
        { 0x00, 0x3C, 0x02, 0x02, 0x3C, 0x00 },      // Code for char Ô
        { 0x00, 0x2A, 0x2A, 0x2A, 0x2A, 0x00 },      // Code for char 
        { 0x00, 0x00, 0x24, 0x2E, 0x24, 0x00 },      // Code for char Ò
        { 0x00, 0x51, 0x4A, 0x4A, 0x44, 0x00 },      // Code for char Ú
        { 0x00, 0x44, 0x4A, 0x4A, 0x51, 0x00 },      // Code for char Û
        { 0x00, 0x00, 0x00, 0xFC, 0x02, 0x04 },      // Code for char Ù
        { 0x00, 0x20, 0x40, 0x3F, 0x00, 0x00 },      // Code for char ı
        { 0x00, 0x08, 0x08, 0x2A, 0x08, 0x08 },      // Code for char ˆ
        { 0x00, 0x24, 0x12, 0x24, 0x12, 0x00 },      // Code for char ˜
        { 0x00, 0x06, 0x09, 0x09, 0x06, 0x00 },      // Code for char ¯
        { 0x00, 0x00, 0x18, 0x18, 0x00, 0x00 },      // Code for char ˘
        { 0x00, 0x00, 0x08, 0x00, 0x00, 0x00 },      // Code for char ˙
        { 0x00, 0x30, 0x40, 0x3E, 0x02, 0x02 },      // Code for char ˚
        { 0x00, 0x01, 0x0E, 0x01, 0x0E, 0x00 },      // Code for char ¸
        { 0x00, 0x09, 0x0D, 0x0A, 0x00, 0x00 },      // Code for char ˝
        { 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x00 },      // Code for char ˛
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },       // Code for char ˇ
};


/*********************************************************************
* Function: OLED_WriteOneChar
* Overview: 
* Input:
* Output: 
********************************************************************/
static void OLED_WriteOneChar(char letter, BYTE page, BYTE column, BOOL invert)
{
    letter -= ' ';      // Adjust character to table that starts at 0x20
    OLED_Select();
    column += OFFSET; // why, we don't know, argggg...
    OLED_SetRAMaddr(page,column);
    ROM BYTE *p = & Terminal8x6[(short)letter][0];
    BYTE i;
    // sequential writes go "downwards" on screen within character cell
    for(i=0; i<6; i++) {
        BYTE d = *p++;
        if(invert) d = ~d;
        OLED_WriteData(d);
    };
    OLED_Deselect();
}


#if 0
  /*********************************************************************
  * Function: OLED_PutROMStringInvertOption()
  * Overview: Prints ROM stored strings.           
  * Input: pointer to ROM stored string, page, column and invert option
  * Output: print the string on OLED_
  ********************************************************************/
  void OLED_PutROMStringInvertOption(ROM_STRING ptr, BYTE row, BYTE column, BOOL invert)
  {
    BYTE _column;
    
    if((page>=0)&&(page<8))
    {   
        _column = column;
        page += 0xB0;
        while(*ptr)
        {
            OLED_WriteOneChar(*ptr, page, _column, invert);
            ptr++;
            _column+=6;
        }
    }
  }
#endif

/*********************************************************************
* Function: OLED_PutStringInvertOption()
* Overview: Prints RAM stored strings..            
* Input: RAM string, page, column and invert option
* Output: print the string on OLED_
********************************************************************/
void OLED_PutStringInvertOption(const char* ptr, BYTE page, BYTE column, BOOL invert)
{
    BYTE _column;
    if((page>=0)&&(page<8))
    {   
        _column = column;
        page += 0xB0;
        while(*ptr)
        {
            OLED_WriteOneChar(*ptr,  page, _column, invert);
            ptr++;
            _column+=6;
        }
    }
}

#if 0
  void OLED_Scroll_Down(void) { // make room on top row
    BYTE p, j;
    OLED_Select();
    for(p=0xB7; p>0xB0; p--) { // Go through all 8 pages
        for(j = 0; j < 132; j++) {
            OLED_SetRAMaddr(p-1, j);
            OLED_Read(); // dummy read, as required for the SH1101A controller
            BYTE b = OLED_Read();
            OLED_SetRAMaddr(p, j);
            OLED_Write(b); 
        }
    }
    // clear top row
    OLED_SetRAMaddr(0xB0,0);
    for(j = 0; j < 132; j++) { OLED_Write(0); };
    OLED_Deselect();
  }
#endif

void OLED_Scroll_Up(void) { // make room for new bottom row
    BYTE p, j;
    OLED_Select();
    for(p=0xB0; p<0xB7; p++) { // Go through all 8 pages
        for(j = 0; j < 132; j++) {
            OLED_SetRAMaddr(p+1, j);
            OLED_Read(); // dummy read, as required for the SH1101A controller
            BYTE b = OLED_Read();
            OLED_SetRAMaddr(p, j);
            OLED_Write(b);
        }
    }
    // clear bottom row
    OLED_SetRAMaddr(0xB7,0);
    for(j = 0; j < 132; j++) { OLED_Write(0); };
    OLED_Deselect();
}

#if 0 // Dubious image-blast routine (check intent vs. use of "size" parameters)
  /*********************************************************************
  * Function: OLED_PutImage()
  * Overview: Puts on display ROM stored images.            
  * Input: pointer to ROM stored image array,
  * Output: 
  ********************************************************************/
  void OLED_PutImage(ROM_STRING ptr, BYTE sizex, BYTE sizey, BYTE startx, BYTE starty)
  {
    BYTE    _page, _column;

    startx += OFFSET;

    for(_page=(0xB0+starty); _page<(0xB0+sizey); _page++)
    {
        OLED_WriteCommand(+_page);
        OLED_WriteCommand(startx&0x0F);
        OLED_WriteCommand(0x10 | ((startx>>4)&0x0F));
        for(_column=0; _column<sizex; _column++)
        {
            OLED_WriteData(*ptr++);
        }
    }
  }

  ROM BYTE battery[5][34] = {
    { 0xF8, 0xE8, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x38, 0x20, 0xE0, 
      0x1F, 0x17, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1C, 0x04, 0x07 }, 

    { 0xF8, 0xE8, 0xE8, 0xE8, 0xE8, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x38, 0x20, 0xE0, 
      0x1F, 0x17, 0x17, 0x17, 0x17, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1C, 0x04, 0x07 }, 

    { 0xF8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x38, 0x20, 0xE0, 
      0x1F, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1C, 0x04, 0x07 }, 

    { 0xF8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0x08, 0x08, 0x08, 0x38, 0x20, 0xE0, 
      0x1F, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x10, 0x10, 0x10, 0x1C, 0x04, 0x07 }, 

    { 0xF8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0x38, 0x20, 0xE0, 
      0x1F, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x1C, 0x04, 0x07 } }; 

  ROM BYTE wifi[] = { 0xF0, 0x18, 0xF8, 0x38, 0xF8, 0x18, 0xF8, 0x58, 0xF8, 0x08, 0xE8, 0x28, 0x08, 0xA8, 0x08, 0xF0,
                    0x0F, 0x1C, 0x1B, 0x1C, 0x1B, 0x1C, 0x1F, 0x18, 0x1F, 0x10, 0x17, 0x11, 0x10, 0x17, 0x10, 0x0F };

  ROM BYTE bluetooth[] = { 0x00, 0x00, 0xE0, 0xF8, 0xFC, 0xDE, 0xBE, 0x02, 0x36, 0xAE, 0xDE, 0xFC, 0xF8, 0xE0, 0x00, 0x00,
                         0x00, 0x00, 0x07, 0x1F, 0x3F, 0x7B, 0x7D, 0x40, 0x6C, 0x75, 0x7B, 0x3F, 0x1F, 0x07, 0x00, 0x00 };

  ROM BYTE sound[5][36] = {     
    { 0x00, 0xC0, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
      0x00, 0x03, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 

    { 0x00, 0xC0, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE, 0x00, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
      0x00, 0x03, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 

    { 0x00, 0xC0, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE, 0x00, 0x40, 0x80, 0x08, 0x10, 0xE0, 0x00, 0x00, 0x00, 0x00, 
      0x00, 0x03, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0x00, 0x02, 0x01, 0x10, 0x08, 0x07, 0x00, 0x00, 0x00, 0x00 }, 

    { 0x00, 0xC0, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE, 0x00, 0x40, 0x80, 0x08, 0x10, 0xE2, 0x04, 0x04, 0x08, 0xF0, 
      0x00, 0x03, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0x00, 0x02, 0x01, 0x10, 0x08, 0x47, 0x20, 0x20, 0x10, 0x0F }, 

    { 0x00, 0xC0, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE, 0x00, 0x40, 0x80, 0x08, 0x10, 0xE2, 0x04, 0x04, 0x08, 0xF0, 
      0x00, 0x03, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0x00, 0x02, 0x01, 0x10, 0x08, 0x47, 0x20, 0x20, 0x10, 0x0F } }; 

#endif // unused image routine and examples
